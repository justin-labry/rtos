#!/usr/bin/lua

function split(s, delimiter)
    result = {};
    for match in (s..delimiter):gmatch("(.-)"..delimiter) do
        table.insert(result, match);
    end
    return result;
end

-- Get stdout result by command execute
local function execute(command)
    local handle = io.popen(command)
    local result = handle:read('*a')
    handle:close()
    return result:gsub('\n', '')
end

-- Generate empty image of the byte size
local function makeEmptyImage(size, image)
	-- NOTE: fallocate overwrite existed file, so we have to remove it
    os.remove(image)
    local command = 'fallocate -l ' .. size .. ' ' .. image
    return os.execute(command)
end

-- Format device to specific filesystem
local function formatDevice(fileSystem, device)
    local formatter = {
        ['vfat']    = 'mkfs.vfat',
        ['ext2']    = 'mkfs.ext2',
        ['bfs']     = 'mkfs.bfs',
    }

    if fileSystem == 'vfat' then
        local option = '-F32'
    end

    if not formatter[fileSystem] then
        print('Unsupported fifesystem for PacketNgin : ' .. fileSystem)
        return false
    end

    local command
    if option then
        command = 'sudo ' .. formatter[fileSystem] .. ' ' .. option .. ' ' .. device
    else
        command = 'sudo ' .. formatter[fileSystem] .. ' ' .. device
    end
    return os.execute(command .. ' >/dev/null 2>&1')
end

-- Insertfiles to device mapper filesystem
local function insertFiles(device, files, prehook, posthook)
    local inserter = {
        'mkdir -p mnt',
        'sudo mount ' .. device .. ' mnt',
        prehook,
    }

    -- File can be table (src, dst) or plain file string
    for _, file in pairs(files) do
        local src = file
        local dst = 'mnt'

        if type(file) == 'table' then
            src = file['src']
            dst = 'mnt/' .. file['dst']
        end

        local copyCommand = 'sudo cp ' .. src .. ' ' .. dst
        table.insert(inserter, copyCommand)
    end

    table.insert(inserter, posthook)
    table.insert(inserter, 'sync')

    local cleaner = {
        -- Clear generated by-product
        'sudo umount mnt',
        'sudo rm -rf mnt',
    }

    for _, command in pairs(inserter) do
        if not os.execute(command) then
            print('\tFailed to execute command : ' .. command)

            for _, clearCommand in pairs(cleaner) do
                os.execute(clearCommand)
            end
            return false
        end
    end

    for _, clearCommand in pairs(cleaner) do
        os.execute(clearCommand)
    end

    return true
end

-- Partition information { filesystem, size }
local function makePartition(image, partitions)
    local commands = {}

    local prefix = 'sudo parted ' .. image .. ' -- '
    table.insert(commands, prefix .. 'mklabel msdos')

    local start = 1
    local finish = 1

    for _, partition in pairs(partitions) do
        finish = finish + partition['size']
        local range = start .. 'MiB ' .. finish .. 'MiB'
        if partition['size'] < 0 then
            range = start .. 'MiB ' .. '-1s'
        end
        start = finish

        local command = prefix .. 'mkpart primary ' .. partition['kind'] .. ' ' .. range
        table.insert(commands, command)
    end

    table.insert(commands, prefix .. 'set 1 boot on')

    for _, command in pairs(commands) do
        if not os.execute(command) then
            return false
        end
    end

	return true
end

local function burnImage(device, fileSystem, files, hook)
    local result = formatDevice(fileSystem, device)
    if not result then
        print('Failed to format device ' .. device .. ' to ' .. fileSystem)
        return false
    end

    return insertFiles(device, files, hook)
end

local function buildRamdiskImage(files)
    local function calcSize(files)
        -- Get total size of files by bytes
        local command = 'du -cbL ' .. table.concat(files, ' ') .. ' | tail -n1 | cut -f1'
        return execute(command)
    end

    -- Assure size which available for all files by 1024 byte
    local size = 1024 * math.ceil(calcSize(files) / 1024)
    -- Assure metadata size of filesystem
    -- FIXME: it just approximate size of file system experimentally We have to
    --        figure out exact BFS size. Also loader presumes that ramdisk is
    --        under 4MB. Must remove this assumption.
    size = size + 10240
    if size >= 4 * 1024 * 1024 then
        print('\tWe cannot create ramdisk over 4MB' .. ramdisk)
        return false;
    end

    local ramdisk = 'initrd.img'
    if not makeEmptyImage(size, ramdisk) then
        print('\tFailed to create emtpy ramdisk image : ' .. ramdisk)
        return false
    end

    -- Find out which loopback device can be available
    local device = execute('sudo losetup -f')
    -- Use available loopback device for image
    os.execute('sudo kpartx -asv ' .. ramdisk)
    if not burnImage(device, 'bfs', files) then
        print('\tFailed to copy files to emtpy ramdisk image : ' .. table.concat(files, ' '))
        -- Detach loop device
        os.execute('sudo losetup -d ' .. device)
        return false
    end

    os.execute('sudo losetup -d ' .. device)

    print('\tRamdisk image was created : ' .. ramdisk)
    return ramdisk
end

local function buildSystemImage(loader, kernel, ramdisk)
    local function makeGrubImage()
		local command = 'bin/grub-mkimage -O i386-pc -d bin/grub-core -p\\(hd0,msdos1\\)/boot/grub biosdisk part_msdos fat exfat bfs multiboot2 -o bin/grub-core/core.img'
		return os.execute(command)
    end

    local function setupBoot(image)
		local command = 'sudo bin/grub-bios-setup -d bin/grub-core -b boot.img -c core.img ' .. image
		return os.execute(command)
    end

    local grubImageMaker = 'bin/grub-mkimage' --'tools/grub/grub-mkimage'
    if io.open(grubImageMaker, "r") == nil then
        print('\tFailed to find grub utility : ' .. grubImageMaker)
        print('\t\tYou have to compile grub submodule first. See doc/setup.md')
        return false
    end

    local image = 'system.img'
	-- FIXME: remove this hard-coded size
	local size = 64 * 1024 * 1024 -- 64MB
	if not makeEmptyImage(size, image) then
		print('\tFailed to create emtpy system image : ' .. image)
		return false
	end

	if not makeGrubImage() then
		print('\tFailed to make grub image')
		return false
	end
	print('\t\tGrub image created : bin/grub-core/core.img')

	-- Partition information { filesystem, size }
	local partitions = {
		{ kind = 'fat32', size = 4  }, 	-- Root file system (4MB)
		{ kind = 'fat32', size = 12 }, 	-- Boot file system (12MB)
		{ kind = 'ext2',  size = -1 }	-- User file system (Leftover)
	}

	if not makePartition(image, partitions) then
		print('\tFailed to make grub image')
		return false
	end
	print('\t\tPartition created')

    local device = execute('sudo losetup -f')
    os.execute('sudo kpartx -as ' .. image)
    local bootDevice = device .. 'p1'       -- e.g. /dev/loop0p1
    local slice = split(bootDevice, '/')    --      {'', 'dev', 'loop0p1'}
    table.insert(slice, 3, 'mapper')        --      {'', 'dev', 'mapper', 'loop0p1'}
    bootDevice = table.concat(slice, '/')   --      /dev/mapper/loop0p1

    local prefix = 'bin/grub-core/'
    local modules = {
        prefix .. 'boot.mod',
        prefix .. 'crypto.mod',
        prefix .. 'extcmd.mod',
        prefix .. 'gettext.mod',
        prefix .. 'normal.mod',
        prefix .. 'terminal.mod',
        prefix .. 'serial.mod',
        prefix .. 'terminfo.mod'
    }

    local files = {
        -- Copy src file to dst
        { src = loader, dst = 'boot' },
        { src = kernel, dst = 'boot' },
        { src = ramdisk, dst = 'boot' },
        { src = 'bin/grub.cfg', dst = 'boot/grub' },
    }
    for _, module in pairs(modules) do
        table.insert(files, { src = module, dst = 'boot/grub/i386-pc' })
    end

    local prehook = 'sudo mkdir -p mnt/boot/grub/i386-pc'
    if not burnImage(bootDevice, 'vfat', files, prehook) then
        print('\tFailed to copy files to emtpy ramdisk image : ' .. table.concat(files, ' '))
        -- Clean partition mapping information
        os.execute('sudo kpartx -d ' .. device)
        return false
    end
    os.execute('sudo kpartx -d ' .. device)

	if not setupBoot(device) then
		print('\tFailed to setup boot bios')
		return false
	end

    print('\tPacketNgin system image was created : ' .. image)
    return image
end

local function buildKernelImage(kernel)
    local file = 'kernel/' .. kernel
    local symbolMap = 'kernel.smap'
    local kernelImage = 'kernel.bin'

    if not os.execute('bin/smap ' .. file .. ' ' .. symbolMap) then
        return false
    end
    print('\tSymbol map was created : ' .. symbolMap)

    if not os.execute('bin/pnkc ' .. file .. ' ' .. symbolMap .. ' ' .. kernelImage) then
        return false
    end
    print('\tKernel binary image was created : ' .. kernelImage)

    return kernelImage
end

function buildImage()
    print('Generated build files...')
    local loader = 'loader/loader.bin'

    local kernel = buildKernelImage('kernel.elf')
    if not kernel then
        return false
    end

    local ramdisk = buildRamdiskImage({'drivers/*.ko', 'firmware/*'})
    if not ramdisk then
        return false
    end

    local image = buildSystemImage(loader, kernel, ramdisk)
    if not image then
        return false
    end

    return image
end

function cleanImage()
    local files = { 'kernel.bin', 'kernel.smap', 'initrd.img', 'system.img' }
    local exist = {}

    for _, file in pairs(files) do
        if os.execute('rm ' .. file .. ' 2>/dev/null') then
            table.insert(exist, file)
        end
    end
    if next(exist) ~= nil then
        print('Generated build files was cleaned : '.. table.concat(exist, ' '))
    end
    return true
end

local functions = { ['build']=buildImage , ['clean']=cleanImage }
if not arg[1] then
    arg[1] = 'build'
end

if not functions[arg[1]] then
    print('Usage: lua image.lua [build|clean]')
    return
end

if not functions[arg[1]]() then
    print('Failed to ' .. arg[1] .. ' image')
    return false
end
